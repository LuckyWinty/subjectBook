![](/assets/explain.png)由浏览器进程切入：

![](/assets/process.png)

可以分为以下8点：

1. DNS域名解析；
2. 建立TCP连接；
3. 发送HTTP请求，服务器处理请求，返回响应结果；
4. 关闭TCP连接；
5. 浏览器解析HTM；
6. 浏览器布局渲染；

**一、DNS域名解析**

DNS查询分为两个大类：递归查询和迭代查询。递归查询就是首先会在浏览器缓存里查找域名对应的ip地址，没找到再找本地域名服务器中查询域名对应的IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去，这个过程就是迭代查询。直到最后找到对应的ip地址。

优化：

DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

**二、建立TCP连接**

进行三次握手，建立TCP连接。

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN\_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1\(Sequence Number+1\)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN\_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
   完成了三次握手，客户端和服务器端就可以开始传送数据。

```
ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。
TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。
SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
```

**三、发送HTTP请求，服务器处理请求，返回响应结果**

TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.

**四、关闭TCP连接**

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN\_WAIT\_1状态；这表示主机1没有数据要发送给主机2了；

2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN\_WAIT\_2状态；主机2告诉主机1，我“同意”你的关闭请求；

3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST\_ACK状态；

4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME\_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

**五、浏览器渲染**

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。

浏览器从网络或硬盘中获得`HTML`字节数据后会经过一个流程将字节解析为`DOM`树,先将`HTML`的原始字节数据转换为文件指定编码的字符,然后**浏览器会根据**`HTML`**规范来将字符串转换成各种令牌标签，如html、body等。，最终解析成一个树状的对象模型，就是dom树；**

当上述`HTML`代码遇见`<link>`标签时，浏览器会发送请求获得该标签中标记的`CSS，`浏览器获得外部`CSS`文件的数据后，就会像构建`DOM`树一样开始构建`CSSOM`树；

在构建了`DOM`树和`CSSOM`树之后，就需要将DOM树与CSSOM树结合在一起，这就是渲染树。浏览器会先从`DOM`树的根节点开始遍历每个可见节点，对每个可见节点，找到其适配的`CSS`样式规则并应用。渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则**需要计算每个节点在窗口内的确切位置与大小，也就是布局阶段。**

CSS采用了一种叫做盒子模型的思维模型来表示每个节点与其他元素之间的距离，盒子模型包括外边距\(Margin\)，内边距\(Padding\)，边框\(Border\)，内容\(Content\)。页面中的每个标签其实都是一个个盒子。

布局完成之后，就会绘制到页面上，这些过程中，如果有js操作或者其他操作，对元素的颜色，背景等作出改变就会引起重绘，如果有对元素的大小、定位等有改变则会引起回流。

部分浏览器缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。但是当我们访问一些即使属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队。

避免方式：

1、避免频繁改动

2、避免逐条改变样式，使用类名去合并样式

3、将 DOM “离线”

### HTTPS解析过程

HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。

SSL工作在OSI七层模型中的表示层，TCP/IP 四层模型的应用层。

#### SSL握手过程

* 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
* 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
* 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
* 第四阶段 变更密码构件和结束握手协议

SSL协议两个重要概念，SSL会话，SSL连接；SSL连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。

更多：

[https://zhuanlan.zhihu.com/p/26682342](https://zhuanlan.zhihu.com/p/26682342)

[https://segmentfault.com/a/1190000012196642](https://segmentfault.com/a/1190000012196642)

![](/assets/ssl.png)

